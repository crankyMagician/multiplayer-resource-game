# Claude Notes

## Project Runtime Defaults
- Multiplayer default port: `7777` (UDP).
- **Smart IP defaults**: In editor, ConnectUI defaults to `127.0.0.1` (localhost). In exported builds, defaults to `207.32.216.76` (public server). Editor mode ignores saved prefs for IP to prevent stale overrides.
- **Dedicated server detection** (3 triggers, checked in `NetworkManager._ready()`):
  1. `DisplayServer.get_name() == "headless"` — Docker/headless export
  2. `OS.has_feature("dedicated_server")` — Godot dedicated server export
  3. `--server` or `--role=server` in `OS.get_cmdline_user_args()` — CLI flags (MCP `run_multiplayer_session` auto-passes `--role=server`)
- When dedicated mode is detected: auto-calls `host_game("Server")` + `GameManager.start_game()`, skips ConnectUI entirely, skips game world UI setup (HUD, BattleUI, etc.) and camera creation.

## Persistence Architecture (MongoDB + Express API)

### Overview
```
[Godot Game Server] --HTTP--> [Express API :3000] --MongoDB--> [MongoDB :27017]
     |                              (internal only)
     |--UDP 7777--> [Game Clients]
```
- Only the game server talks to the API. Clients get data via RPCs.
- API is internal (ClusterIP in K8s, docker network locally).
- **Editor dev (no Docker)**: SaveManager auto-falls back to file I/O (`user://save/`). No API needed.

### UUID Identity System (CRITICAL)
**Every persistent entity MUST have a stable UUID.** This is required because MongoDB documents are keyed by UUID, not by name or array index.

| Entity | UUID field | Generated by | Stored in |
|--------|-----------|-------------|-----------|
| Player | `player_id` | Express API (`crypto.randomUUID()`) on first join | `players` collection `_id`, `player_data_store[peer_id]["player_id"]` |
| Creature | `creature_id` | Server-side `_generate_uuid()` on creation | Each creature dict in party/storage arrays |

**Rules for UUIDs:**
- **New entities** (players, creatures, future items): ALWAYS generate a UUID on creation. Never rely on array index or display name as an identifier.
- **Existing entities without UUIDs**: Auto-backfilled on load via `_backfill_creature_ids()`. Same function also backfills IVs, bond data via `_backfill_creature_stats()`.
- **Cross-reference by UUID**: Held item equip/unequip, storage deposit/withdraw, battle creature references should use `creature_id` (not party index).
- **Player names are unique** (MongoDB unique index + `active_player_names` runtime check) but names are for display/lookup, NOT identity. The `player_id` UUID is the stable key.
- **If you add a new persistent entity type** (e.g. guilds, mail, auction listings), it MUST get a UUID field generated server-side.

### Express API (`api/`)
- **Tech**: Node 20, Express, MongoDB driver, TypeScript
- **Endpoints**: `GET/PUT /api/players/:id`, `GET /api/players/by-name/:name`, `POST /api/players`, `GET/PUT /api/world`, `GET /health`
- **MongoDB collections**: `players` (keyed by `_id: player_id` UUID, unique index on `player_name`), `world` (single doc `_id: "world_state"`)
- **Image**: `ghcr.io/crankymagician/mt-creature-crafting-api:latest`

### SaveManager (`scripts/autoload/save_manager.gd`)
- **Startup**: checks `SAVE_API_URL` env var → `GET /health` → sets `use_api: bool`. Falls back to file I/O if unreachable.
- **Save flow**: `save_player(data)` → `PUT /api/players/:player_id` (fire-and-forget, auto-save every 60s)
- **Load flow**: `load_player_async(name)` → `GET /api/players/by-name/:name` → emits `player_loaded(name, data)`
- **Create flow**: `create_player_async(data)` → `POST /api/players` → API generates UUID → emits `player_created(name, data)`

### Join Flow (Async, UUID-Aware)
1. Client sends `request_join(player_name)` RPC
2. Server validates name (2-16 chars, alphanumeric + underscores + spaces), checks `active_player_names`
3. Server calls `SaveManager.load_player_async(player_name)` → signal
4. If empty → `create_player_async()` (new player with UUID); if found → `_finalize_join()`
5. `_finalize_join()`: backfills creature UUIDs + IVs + bond data, stores in `player_data_store`, sends `_receive_player_data` RPC

### Docker Compose (Local Dev)
```yaml
services:
  mongodb:     # mongo:7, port 27017, volume mongo_data
  api-service: # builds ./api, port 3000, MONGO_URI
  game-server: # builds ., port 7777/udp, SAVE_API_URL
```
- `docker compose up --build -d` starts all 3 services
- Verify MongoDB: `docker exec mongodb mongosh creature_crafting --eval "db.players.find()"`

## Docker Server Build
See `docs/docker-build.md` for full build instructions (two-phase engine + game build, SCons flags, local dev).

## Multiplayer Join/Spawn Stabilization
- **Client pre-loads GameWorld on connect**: `_on_connected_to_server()` calls `GameManager.start_game()` BEFORE `request_join`. This ensures the MultiplayerSpawner exists before spawn replication RPCs arrive.
- **Name uniqueness**: `active_player_names` dict (name → peer_id) rejects duplicate online names. `_join_rejected` RPC tells client why.
- Spawn waits for client world path readiness (`/root/Main/GameWorld/Players/MultiplayerSpawner`).
- Server tracks temporary join state and times out peers that never become ready.
- **New player spread spawn**: Players with no saved position spawn in a golden-angle circle (radius 2, center 0,0,3) to avoid overlap.

## Player/Camera Notes
- Player movement uses server authority with replicated input.
- Camera defaults to over-the-shoulder and captures mouse during world control. Mouse made visible during battle UI and recaptured after.
- **Server has no camera or UI** — `game_world.gd` `_ready()` skips `_setup_ui()` and `_ensure_fallback_camera()` on the server.
- **Player collision layers**: Players use `collision_layer=2`, `collision_mask=1`. TallGrass and TrainerNPC Area3Ds set `collision_mask=3` (bits 1+2) to detect players.
- **UI node sharing**: `_setup_ui()` adds HUD, BattleUI, CraftingUI, InventoryUI, PartyUI to the **existing** `$UI` node from `game_world.tscn`. Do NOT create a new "UI" node — Godot will rename it, breaking path lookups.
- **Player visuals** (color, nameplate): set on the player node server-side **before** `add_child()` in `_spawn_player()`, synced via StateSync spawn-only mode.
- **StateSync properties** (5 total): `position`, `velocity` (always), `player_color`, `player_name_display` (spawn-only), `mesh_rotation_y` (always).

## Battle System
- **3 battle modes**: Wild, Trainer (7 NPCs), PvP (V key challenge within 5 units of another player)
- **21 creatures** (9 original + 9 gen2 + 3 evolutions), 7 evolution chains, MAX_PARTY_SIZE = 3
- **Starter creature**: All new players spawn with Rice Ball (Grain, Lv 5, 45 HP) with moves: grain_bash, quick_bite, bread_wall, syrup_trap
- **57 moves** including weather setters, hazards, protection, charging, multi-hit, recoil, drain, crit-boosters, taunt, trick room, substitutes
- **20 abilities** with trigger-based dispatch (on_enter/on_attack/on_defend/on_status/end_of_turn/on_weather)
- **18 held items** (6 type boosters, 6 utility, 3 choice items, 3 specialist) — all craftable from ingredients
- **XP/Leveling**: XP from battles, level-up stat recalc, learnset moves, evolution. Full XP to participants, 50% to bench.
- **AI**: 3 tiers (easy=random, medium=type-aware, hard=damage-calc + prediction)
- **PvP**: Both-submit simultaneous turns, 30s timeout, disconnect = forfeit. Loser forfeits 25% of each ingredient stack to winner.
- **Defeat penalty**: 50% money loss, teleport to spawn point, all creatures healed

### IVs, Bond, and Crit Stages
- **IVs**: 6 stats (hp/atk/def/spa/spd/spe), 0-31 range, rolled on creation via `CreatureInstance.create_from_species()`. Formula: `stat = int(base_stat * level_mult) + iv`. Old saves auto-backfilled. `CreatureInstance.IV_STATS` constant.
- **Bond**: Points earned via battles (+10 active, +1 bench) and feeding (+15). Levels 0-5, thresholds: 50/150/300/500/750 (`CreatureInstance.compute_bond_level()`). Modifiers: Lv2 +5% accuracy, Lv3 1.2x XP, Lv4 endure (survive lethal hit at 1 HP once), Lv5 +10% all stats. Battle affinities tracked for future expansion.
- **Crit stages**: Per-creature 0-3, rates: 6.25%/12.5%/25%/50% (`BattleCalculator.get_crit_stage()`). Moves modify via `self_crit_stage_change`. Resets each battle.
- **Taunt**: `taunt_turns` (3 turns), prevents status moves. Validated in `request_battle_action()`.
- **Trick Room**: `trick_room_turns` on battle dict, reverses speed priority.
- **Substitutes**: `substitute_hp` per creature, absorbs damage before real HP. Sound moves bypass.

### New Move Properties (MoveDef)
- `self_crit_stage_change: int` — crit stage modifier on use
- `is_sound: bool` — bypasses substitutes
- `taunts_target: bool` — applies taunt on hit
- `knock_off: bool` — removes defender's held item
- `sets_trick_room: bool` — toggles trick room

### Battle UI
- **Enemy panel**: name, level, types, HP bar, status, stat stages, crit stage
- **Player panel**: name, level, types, HP bar, XP bar, ability, held item
- **Move buttons**: 3-line format — Name / Type|Category|Power / Accuracy|PP
- **Field effects bar**: trick room, taunt turns, substitute HP, crit stage
- **Weather bar**: weather name + remaining turns
- **Flee/Switch**: Flee in wild only, Switch always available
- **Turn log**: scrolling RichTextLabel. Ability messages in `[color=purple]`, item in `[color=cyan]`, effectiveness in green/yellow.
- **Summary screen**: Victory/Defeat, XP per creature (level-up highlights), item drops, trainer money + bonus ingredients. Continue button returns to world.
- **PvP-specific**: no Flee, "Waiting for opponent..." label, perspectives actor-swapped. PvP challenge UI auto-hides when battle starts.
- **Trainer prompt cleanup**: `_on_battle_started()` calls `hud.hide_trainer_prompt()`.

### Battle Manager Server-Side
- Battle state keyed by `battle_id` (auto-increment), `player_battle_map[peer_id] → battle_id`
- **Server-authoritative party data**: `_build_party_from_store(peer_id)` reads party from `NetworkManager.player_data_store`, NOT from client. No `_receive_party_data` RPC exists.
- **Move validation**: `request_battle_action()` verifies move_id exists in creature's actual moveset. Switch targets bounds-checked.
- Wild/Trainer: server picks AI action, resolves turn, sends `_send_turn_result` RPC
- PvP: both sides submit via `request_battle_action` RPC, server resolves when both received. `_swap_actor()` flips perspective for each player's log.
- Rewards via separate RPCs: `_grant_battle_rewards`, `_send_xp_results`, `_grant_trainer_rewards_client`, `_battle_defeat_penalty`
- **Party deep-copy**: `server_update_party()` uses `.duplicate(true)` to prevent cross-player state corruption.

## Crafting & Item System (Unified Overhaul)
- **52 recipes**: 13 creature (cauldron, unlockable), 18 held item (workbench), 12 food (kitchen), 9 tool upgrade (workbench)
- **5 item types**: ingredients (16), held items (18), foods (12), tools (12), recipe scrolls (13) — all share single inventory namespace
- **3 crafting stations**: Kitchen (restaurant zone), Workbench (near spawn), Cauldron (deep wild zone) — each filters recipes by `station` field
- **Recipe unlock system**: Creature recipes require recipe scrolls to unlock. Scrolls come from trainer first-defeat rewards, world pickups, or fragment collection (3-5 fragments auto-combine)
- **Food & buffs**: 4 buff foods (speed_boost, xp_multiplier, encounter_rate, creature_heal) + 8 trade goods for selling. Buffs are timed, server-side expiry checked every 5s
- **Tool upgrades**: 3 tool types (hoe, axe, watering_can) x 4 tiers (basic→bronze→iron→gold). Upgrade recipes consume old tool + ingredients. Dynamic stats from ToolDef
- **Crafting security**: Single-phase server-authoritative — `request_craft(recipe_id)` RPC validates everything server-side, deducts, produces result, syncs to client. No client-side deduction.
- **Selling**: `request_sell_item(item_id, qty)` RPC for food trade goods with sell_price
- **16 ingredients**: farm crops (season-locked) + battle drops. New plantable crops: lemon (summer), pickle_brine (autumn)
- **Planting flow** (server-authoritative): Client sends `request_farm_action(plot_idx, "plant", seed_id)` RPC. Server removes seed from `player_data_store`, attempts plant, rolls back on failure. No client-side deduction.
- **Watering flow** (server-authoritative): Client sends `request_farm_action(plot_idx, "water", "")` RPC. Server decrements, syncs via `_sync_watering_can` RPC. Refill via `_request_refill` RPC.

### Buff Application Points
- **Speed boost**: `player_controller.gd` `_physics_process()` — multiplies move speed
- **XP multiplier**: `battle_manager.gd` `_grant_xp_for_defeat()` — multiplies XP
- **Encounter rate**: `encounter_manager.gd` `get_encounter_rate_multiplier()` — multiplies probability

### PlayerData Tool System
- **No Tool enum** — replaced with string-based `current_tool_slot` ("", "hoe", "axe", "watering_can", "seeds")
- `equipped_tools: Dictionary` maps tool_type → tool_id (e.g. `{"hoe": "tool_hoe_basic", ...}`)
- `get_watering_can_capacity()` reads from equipped ToolDef's effectiveness dict
- `known_recipes: Array` tracks unlocked recipe IDs
- `active_buffs: Array` of `{buff_type, buff_value, expires_at}` dicts

## World Item Drop & Pickup System
- **WorldItemManager** (`scripts/world/world_item_manager.gd`): Server-authoritative manager in `game_world.tscn`
- **WorldItem** (`scripts/world/world_item.gd`): Area3D pickup node with colored BoxMesh, billboard Label3D, bobbing animation, walk-over auto-pickup
- **Pickup flow**: Area3D `body_entered` (server-only) → `WorldItemManager.try_pickup()` → `server_add_inventory()` + `_sync_inventory_full` RPC → `_notify_pickup` RPC (HUD toast) → `_remove_world_item()` (despawn RPC to all)
- **Drop sources**: Random world forage spawns (every 120s, 10 spawn points), farm plot clearing
- **Late-joiner sync**: `sync_all_to_client(peer_id)` sends bulk `_spawn_world_item_client` RPCs
- **Persistence**: `get_save_data()` / `load_save_data()` integrated into `game_world.gd` save/load flow
- **Node naming**: `"WorldItem_" + str(uid)` with monotonic auto-increment UIDs to avoid duplicate name trap

## World Layout
- **Hub area**: Players spawn near (0, 1, 3). Farm zone at (25, 0, 0). Restaurant doors at z=12.
- **Decorative nodes** in `game_world.tscn` under GameWorld: `Paths`, `Signposts`, `Trees`, `ZoneOverlays`
- **Trainer progression**: Optional trainers flank the main path south; gatekeepers block advancement to deeper zones

## Wild Encounter Zones
- 6 zones total: Herb Garden, Flame Kitchen, Frost Pantry, Harvest Field, Sour Springs, Fusion Kitchen
- Represented by glowing colored grass patches with floating in-world labels
- HUD provides persistent legend + contextual hint when inside encounter grass

## NPC Trainers
- 7 trainers placed along world paths under `Zones/Trainers` in game_world.tscn
- Color-coded by difficulty: green=easy, yellow=medium, red=hard
- Trainers: Sous Chef Pepper, Farmer Green, Pastry Chef Dulce, Brinemaster Vlad, Chef Umami, Head Chef Roux, Grand Chef Michelin
- **Optional** (`is_gatekeeper=false`): Pepper, Green, Dulce, Vlad, Michelin — E-key prompt via `_show_trainer_prompt` RPC, `request_challenge` RPC to start. Rematch cooldown per trainer.
- **Gatekeeper** (`is_gatekeeper=true`): Umami, Roux — forced pushback + TrainerDialogueUI (Accept/Decline). Defeating records `defeated_trainers[trainer_id]` in player_data_store, `_notify_gate_opened` RPC hides gate per-client. Detection radius: 4.0 gatekeepers, 3.0 optional.

## Restaurant System
- **Architecture**: Server-authoritative, per-player restaurant instances with own interior scene, farm plots, kitchen crafting station.
- **Instance positioning**: `Vector3(1000 + idx*200, 0, 1000)` — far from overworld. Index persisted in player save data.
- **Unique instance names**: `Restaurant_<owner_name>` set before `add_child()` to prevent Godot auto-rename.
- **Entry/exit flow**: Walk-over door (Area3D) → server saves overworld position → teleports to interior → `_notify_location_change` RPC → client instantiates scene. Exit via ExitDoor restores overworld position.
- **Farm routing**: `get_farm_manager_for_peer(peer_id)` checks `player_location` dict — returns restaurant's or overworld FarmManager.
- **Persistence**: Restaurant index map in world data. Farm plots saved to `player_data_store["restaurant"]` on unload/auto-save.
- **Auto-save position fix**: Both `save_manager.gd` and `network_manager.gd` check `RestaurantManager.overworld_positions[peer_id]` before falling back to `player_node.position` — prevents saving interior coordinates as overworld position.
- **Unloading**: When all players leave, saves farm data and `queue_free()`s the instance.
- **Files**: `scripts/world/restaurant_manager.gd`, `restaurant_interior.gd`, `restaurant_door.gd`, `scenes/world/restaurant_interior.tscn`

## Networking Rules (IMPORTANT)

This is a server-authoritative multiplayer game. **Every gameplay change — new feature, new action, new resource, any UI that affects game state — must be evaluated for networking impact.** If the user does not specify whether a change should be networked, always ask before implementing.

### Questions to resolve before writing code
- Should this run on **server only**, **client only**, or **both**?
- Does the server need to **validate/authorize** this action? (Almost always yes for anything that changes player data, inventory, party, or world state.)
- Do other clients need to **see the result**? If so, how is it synced — RPC, MultiplayerSynchronizer property, or MultiplayerSpawner?
- Is there a **race condition** if the client optimistically updates before the server confirms?

### Authority model
| System | Authority | Sync mechanism |
|--------|-----------|---------------|
| Player movement/rotation | Server (`_physics_process`) | StateSync (position, velocity, mesh_rotation_y) |
| Player visuals (color, name) | Server (set before spawn) | StateSync (spawn-only) |
| Camera / input | Client (InputSync) | InputSync → server reads |
| Inventory changes | Server (`server_add/remove_inventory`) | RPC to client |
| Farm actions (plant/water/harvest/till) | Server (`request_farm_action` RPC) | Server validates, then RPC result to client |
| Battle state | Server (BattleManager) | RPCs to involved clients |
| Crafting | Server (`request_craft` single-phase) | RPC results + inventory sync to client |
| Food/buffs | Server (`request_use_food`) | `_sync_active_buffs` RPC to client |
| Tool/held item equip | Server (`request_equip_*` RPCs) | Sync RPCs to client |
| World item spawn/pickup | Server (WorldItemManager) | `_spawn/_despawn_world_item_client` RPCs to all |
| Restaurant entry/exit | Server (RestaurantManager) | `_notify_location_change` RPC |
| Calendar/weather | Server (SeasonManager) | `_broadcast_time` RPC to all |
| Save/load | Server only (SaveManager → Express API → MongoDB) | Data sent to client via `_receive_player_data` |

### Never do this
- **Never deduct resources client-side before server confirms.** Always let the server deduct first, then sync to client via RPC. The old planting flow had this bug — client removed seed, then told server, creating desync on disconnect.
- **Never assume a gameplay feature is local-only** unless explicitly told so. Even "cosmetic" things like player color need syncing in multiplayer.
- **Never modify `PlayerData` (the autoload) on the server.** `PlayerData` is the client's local mirror. The server uses `NetworkManager.player_data_store[peer_id]`. Sync changes from server store to client PlayerData via RPC.

## Calendar & Weather System (Stardew-style)
- **SeasonManager** (`scripts/world/season_manager.gd`): Server-authoritative time progression
- **Day cycle**: 10 real minutes per in-game day (`DAY_DURATION = 600.0`)
- **Seasons**: 14 days per season, 4 seasons per year (Spring → Summer → Autumn → Winter)
- **Weather**: 4 types — Sunny (50%), Rainy (25%), Windy (15%), Stormy (10%). Rolled each day.
- **Rain auto-waters**: On rainy/stormy days, `_rain_water_all_farms()` waters all FarmManagers
- **HUD display**: `season_label` shows "Year N, Season Day D", `day_label` shows weather name
- **Crop seasons**: `is_crop_in_season(crop_season)` validates planting — crops have slash-separated season strings (e.g. `"spring/summer"`)
- **Sync**: Server broadcasts `_broadcast_time` RPC on day advance. Late-joiners request via `request_season_sync` RPC.
- **Persistence**: Full state saved/loaded — `current_year`, `day_in_season`, `day_timer`, `total_day_count`, `current_weather`, `current_season`. Backward-compat with old fields.

## GDScript Conventions
- Use `class_name` for static utility classes (BattleCalculator, StatusEffects, FieldEffects, AbilityEffects, HeldItemEffects, BattleAI)
- Do NOT preload scripts that already have `class_name` — causes "constant has same name as global class" warning
- Prefix unused parameters/variables with `_` to suppress warnings
- Use `4.0` instead of `4` in division to avoid integer division warnings

## Export Build Gotchas
- **DataRegistry .tres/.remap handling**: Godot exports convert `.tres` to `.tres.remap`. Any code using `DirAccess` to scan for resources must check `.tres`, `.res`, AND `.remap` extensions.
- **Battle stacking prevention**: All encounter/battle entry points must check `BattleManager.player_battle_map` before starting a new battle. Client-side `start_battle_client()` also guards against duplicate RPCs.
- **stdbuf for Docker logs**: Godot headless buffers stdout. Dockerfile uses `stdbuf -oL` for line-buffered output.
- **Duplicate node name trap**: If a .tscn already has child "X", creating a new `Node("X")` + `add_child()` causes silent rename. Always use `get_node("X")` for existing nodes.
- **CanvasLayer child visibility**: Hiding CanvasLayer children requires explicit restore on next use. CanvasLayer's own `visible` doesn't propagate. `_on_battle_started()` restores all children.
- **MCP addon excluded from server export**: `export_presets.cfg` has `exclude_filter="addons/mechanical_turk_mcp/*"`. Non-fatal "File not found" on startup is expected.
- **Connection timeout**: ConnectUI has a 10-second timeout for transport-connected but multiplayer-rejected peers.

## Kubernetes Deployment
See `docs/k8s-deployment.md` for full K8s deployment details (3 deployments, SSH access, deploy workflow, manifests).

## MCP Testing Workflow
See `docs/mcp-testing.md` for full MCP testing guide (editor bridge, runtime bridge sessions, caveats, port conflicts).

## File Structure Overview
- `api/` — Express API service (TypeScript): `src/index.ts`, `src/routes/players.ts`, `src/routes/world.ts`, `Dockerfile`
- `k8s/` — Kubernetes manifests: `mongodb.yaml`, `api-service.yaml`, `deployment.yaml`, `service.yaml`
- `scripts/autoload/` — NetworkManager, GameManager, PlayerData, SaveManager
- `scripts/data/` — 13 Resource class definitions (+ food_def, tool_def, recipe_scroll_def)
- `scripts/battle/` — BattleManager, BattleCalculator, StatusEffects, FieldEffects, AbilityEffects, HeldItemEffects, BattleAI
- `scripts/world/` — FarmPlot, FarmManager, SeasonManager, TallGrass, EncounterManager, GameWorld, TrainerNPC, CraftingStation, RecipePickup, WorldItem, WorldItemManager, RestaurantManager, RestaurantInterior, RestaurantDoor
- `scripts/crafting/` — CraftingSystem
- `scripts/player/` — PlayerController, PlayerInteraction
- `scripts/ui/` — ConnectUI, HUD (calendar + weather + trainer prompt), BattleUI, CraftingUI (station-filtered), InventoryUI (tabbed), PartyUI (networked equip), PvPChallengeUI, TrainerDialogueUI (gatekeeper accept/decline + post-battle dialogue)
- `resources/` — ingredients/ (16), creatures/ (21), moves/ (57), encounters/ (6), recipes/ (52), abilities/ (20), held_items/ (18), trainers/ (7), foods/ (12), tools/ (12), recipe_scrolls/ (13)
